#!/bin/sh

# Player binaries path
PLAYER_32_BIT=qua_player_32_gcc

# Configurations
CORES="2,3"				# Which core(s) you want the player to play on. Example: "3,4,5" or "2". This is zero indexed.
VALID_BIT_DEPTH="16 32" # List of valid Bit-depths your hardware supports.
FORCE_BIT_DEPTH=32		# Force playback at a specific sample rate. Options: false OR user define value
FALLBACK_BIT_DEPTH=32	# Fallback bit-depth, used when detected bit-depth is not within VALID_BIT_DEPTH
VALID_SAMPLE_RATES="44100 48000 88200 96000 176400 192000 352800 384000" # List of valid sample rates
FORCE_SAMPLE_RATE=false # Force playback at a specific sample rate. Options: false OR user define value
FALLBACK_SAMPLE_RATE=96000 # Fallback bit-depth, used when detected bit-depth is not within VALID_BIT_DEPTH

FILE="$1"
DEVICE="hw:0,0"

main() {
    setup_format
    wav_conversion
    post_processing
    playback
}

setup_format() {
    # Determining Bit-Depth for playback
    detected_bit_depth=$(sox --i -p "$TEMP_WAV_INTERMEDIATE" 2>/dev/null)
    echo "Detected bit-depth: $detected_bit_depth"
    
    # Todo: Clean up logic a bit -> Fallback Rate, then Detected Rate, then Forced Rate
    if [ "$FORCE_BIT_DEPTH" != "false" ]; then
        playback_bit_depth="$FORCE_BIT_DEPTH"
        echo "Playback using FORCED $playback_bit_depth bits"
    else
        # Check if detected bit depth is valid
        playback_bit_depth="$FALLBACK_BIT_DEPTH"
        for bit_depth in $VALID_BIT_DEPTH; do
            if [ "$detected_bit_depth" = "$bit_depth" ]; then
                playback_bit_depth="$detected_bit_depth"
                break
            fi
        done
        echo "Playback using $playback_bit_depth bits"
    fi
    
    if [ "$playback_bit_depth" = "16" ]; then
        PLAYER="$PLAYER_16_BIT"
    else
        PLAYER="$PLAYER_32_BIT"
    fi
    
    # Determining Sample Rate for playback
    # Todo: Clean up logic a bit -> Fallback Rate, then Detected Rate, then Forced Rate
    detected_sample_rate=$(sox --i -r "$FILE" 2>/dev/null)
    echo "Detected sample rate: $detected_sample_rate Hz"
    if [ "$FORCE_SAMPLE_RATE" != "false" ]; then
        playback_sample_rate="$FORCE_SAMPLE_RATE"
        echo "Playback using FORCED $playback_sample_rate Hz"
    else
        # Check if detected sample rate is valid
        playback_sample_rate="$FALLBACK_SAMPLE_RATE"
        for rate in $VALID_SAMPLE_RATES; do
            if [ "$detected_sample_rate" = "$rate" ]; then
                playback_sample_rate="$detected_sample_rate"
                break
            fi
        done
        echo "Playback using $playback_sample_rate Hz"
    fi
}

wav_conversion() {
    # Generate temp filename in shared memory
    TEMP_WAV_INTERMEDIATE="/dev/shm/sa_temp_raw_$$.wav"
    EXT="${FILE##*.}"
    # Perform conversion based on file format
    case "$EXT" in
        "flac")
            flac -d -c "$FILE" > "$TEMP_WAV_INTERMEDIATE"
        ;;
        "wv")
            wvunpack "$FILE" -o "$TEMP_WAV_INTERMEDIATE"
        ;;
        "ape")
            mac "$FILE" -d "$TEMP_WAV_INTERMEDIATE"
        ;;
        "mp3")
            lame --decode "$FILE" "$TEMP_WAV_INTERMEDIATE"
        ;;
        "m4a"|"mp4"|"opus"|"ogg"|"wav"|"aiff")
            ffmpeg -v quiet -i "$FILE" -f wav "$TEMP_WAV_INTERMEDIATE"
        ;;
        *)
            echo "Unsupported file format: $EXT"
            exit 1
        ;;
    esac
}


# Todo: Some bugs playing very short files, exits too quick
post_processing() {
    # Generate final output filename
    TEMP_WAV_PLAYBACK="/dev/shm/sa_temp_playback_$$.wav"
    # Apply sample rate, bit depth, and padding using SoX
sox -V3 "$TEMP_WAV_INTERMEDIATE" -t wav -b "$playback_bit_depth" -e signed-integer "$TEMP_WAV_PLAYBACK" rate -v "$playback_sample_rate" pad 0.2 0
}

playback() {
    echo "Starting playback using: $PLAYER"
    nohup setsid taskset -c "$CORES" "$PLAYER" "$TEMP_WAV_PLAYBACK" "$DEVICE" $$  </dev/null >/dev/null 2>&1 &
#    "$PLAYER" "$TEMP_WAV_PLAYBACK" "$DEVICE" $$
}

cleanup() {
    echo "Cleaning up temporary files..."
    sleep 2
    rm -f /dev/shm/sa_temp_*_$$.wav 2>/dev/null
    echo "Cleanup complete"
}

# Set trap to catch interrupts and exits
trap cleanup EXIT INT TERM

# Call main function
main
